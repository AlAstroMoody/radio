# План рефакторинга аудио‑архитектуры

## Цели
- Один источник аудио и единая точка управления воспроизведением.
- Чёткое разделение ответственности между данными, плеером и UI.
- Контролируемые записи в persistent‑хранилища, отсутствие скрытых сайд-эффектов.
- Упрощение поддержки: понятные контракты, юнит‑тесты для критичных частей.

## Архитектурный обзор
- **AudioRoot (провайдер)**  
  - Инкапсулирует `<audio>` и `AudioContext`.  
  - Экспортирует API (`play`, `pause`, `load`, `seek`, `getAnalyser`, события).  
  - Предоставляет состояние через provide/inject или Pinia (см. ниже).
- **PlaybackStore / Pinia‑модуль**  
  - Хранит текущий источник (radio / local / external), очередь, историю, состояние воспроизведения.  
  - Управляет загрузкой станций, локальных файлов, кэшированием и порядком.  
  - Изолирует работу с `localStorage`/`IndexedDB` (throttle, миграции).
- **UI‑слой**  
  - Компоненты (`RadioPlayer`, `MusicPlayer`, `AudioControls`, `ProgressBar`) получают данные через провайдер + стор.  
  - Мини‑плеер / глобальная панель получает доступ к общему состоянию и управлению.  
  - Визуализация использует единственный `AnalyserNode`, предоставленный провайдером.
- **Сервисы и эффектные композаблы**  
  - `AudioService` становится адаптером вокруг `AudioRoot` (без прямых DOM‑манипуляций).  
  - `useAudioSettings`, `useVisualizer`, `useMediaSession` работают с провайдером/стором, не ищут элементы в DOM.

## Этапы работ

### 1. Подготовка
- [ ] Создать `AudioRoot` компонент/компосабл с единым `<audio>` и API.
- [ ] Описать типы: `Track`, `SourceType`, `PlaybackState`, `QueueItem`.
- [ ] Настроить Pinia‑модуль (или общий composable) для PlaybackStore.

### 2. Миграция существующих плееров
- [ ] Перевести RadioPlayer на новый API (загрузка по ID станции → `playTrack` провайдера).  
- [ ] Перевести локальный MusicPlayer на тот же API (создание `Track` из `File`, работа с очередью).  
- [ ] Удалить прямое создание `<audio>` в компонентах, заменить на inject/useAudio().

### 3. Управление состоянием и кэширование
- [ ] Вынести работу с `localStorage`/`IndexedDB` в слой PlaybackStore; добавить throttle сохранений, флаги миграции.  
- [ ] Восстановить порядок станций/файлов внутри стора (без перезаписи массива, если данные не изменились).  
- [ ] Расширить/описать кэш API станций (ошибки не затирают сохранённые данные).

### 4. Визуализация и эффекты
- [ ] Обновить `useVisualizer` для работы с единым `AnalyserNode`.  
- [ ] Перенести эквалайзер и фильтры в AudioRoot/AudioService; `useAudioSettings` только меняет состояние стора.  
- [ ] Убрать `document.querySelector` из composables, передавать ссылки через провайдер.

### 5. UI рефакторинг
- [ ] Создать общий компонент `GlobalAudioBar` (мини‑плеер) и подключить его к провайдеру.  
- [ ] Согласовать управление модалками/панелями (использовать события стора, а не прямые watchers).  
- [ ] Единый набор контролов (`AudioControls`, `ProgressBar`) → работает и для радио, и для файлов.

### 6. Тестирование и мониторинг
- [ ] Написать юнит‑тесты для PlaybackStore, AudioRoot API (mock Audio).  
- [ ] Добавить dev‑инструмент (например, overlay) для логирования событий воспроизведения и частоты сохранений.  
- [ ] Провести профилирование (Chrome Performance) до/после, зафиксировать результаты.

### 7. Завершение и документация
- [ ] Обновить README/внутреннюю документацию (описание AudioRoot, стора, API компонентов).  
- [ ] Создать диаграмму потоков данных (AudioRoot ⇆ Store ⇆ Components).  
- [ ] Вынести регрессионные тесты/чек-лист (проверка сохранения позиций, кэша станций, визуализации).

## Дополнительные идеи
- Поддержка нескольких очередей и плейлистов (радио + локальный + внешние ссылки).  
- Интеграция Media Session API (обновление метаданных, обработка `seekto`).  
- Добавление аналитики/метрик (в dev‑режиме) для отслеживания числа операций записи и частоты переключения треков.  
- Возможность расширения на PWA/offline (кэш потоков/файлов при необходимости).

---
Этот план можно уточнять по мере внедрения: после этапа 2 провести ретроспективу, скорректировать приоритеты и оценить трудозатраты следующих шагов.

